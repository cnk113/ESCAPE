% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EnImpute.R
\name{EnImpute}
\alias{EnImpute}
\title{Run EnImpute on a raw read count matrix}
\usage{
EnImpute(count, scale.factor = 10000, trim = 0.3, ALRA = TRUE,
  DCA = TRUE, DrImpute = TRUE, MAGIC = TRUE, SAVER = TRUE,
  scImpute = TRUE, scRMD = TRUE, Seurat = TRUE, ALRA.k = 0,
  ALRA.q = 10, DCA.normtype = "zheng", DCA.type = "zinb-conddisp",
  DCA.l2 = 0, DCA.l1 = 0, DCA.l2enc = 0, DCA.l1enc = 0, DCA.ridge = 0,
  DCA.gradclip = 5, DCA.activation = "relu", DCA.hiddensize = "64,32,64",
  DCA.hyper = FALSE, DCA.hypern = 1000, DrImpute.ks = 10:15,
  DrImpute.dists = c("spearman", "pearson"), DrImpute.method = "mean",
  DrImpute.cls = NULL, MAGIC.k = 10, MAGIC.alpha = 15, MAGIC.t = "auto",
  MAGIC.npca = 20, MAGIC.t.max = 20, MAGIC.knn.dist.method = "euclidean",
  MAGIC.n.jobs = 1, SAVER.do.fast = TRUE, SAVER.ncores = 2,
  SAVER.size.factor = NULL, SAVER.npred = NULL, SAVER.null.model = FALSE,
  SAVER.mu = NULL, scImpute.drop_thre = 0.5, scImpute.Kcluster = 5,
  scImpute.labeled = FALSE, scImpute.labels = NULL,
  scImpute.genelen = NULL, scImpute.ncores = 1, scRMD.tau = NULL,
  scRMD.lambda = NULL, scRMD.candidate = 0.05, Seurat.genes.use = NULL,
  Seurat.genes.fit = NULL, Seurat.gram = TRUE)
}
\arguments{
\item{count}{raw read count matrix. The rows correspond to genes and the columns correspond to cells.}

\item{scale.factor}{scale factor used to re-scale the imputed results generated by
different individual methods. Default is 10000.}

\item{trim}{specifies the fraction (between 0 and 0.5)  of observations to be trimmed
from each end before the mean is computed. Default is 0.3.}

\item{ALRA}{a boolean variable that defines whether to impute the raw data using the ALRA method.
Default is TRUE.}

\item{DCA}{a boolean variable that defines whether to impute the raw data using the DCA method.
Default is TRUE.}

\item{DrImpute}{a boolean variable that defines whether to impute the raw data using the DrImpute method.
Default is "TRUE".}

\item{MAGIC}{a boolean variable that defines whether to impute the raw data using the MAGIC method.
Default is TRUE.}

\item{SAVER}{a boolean variable that defines whether to impute the raw data using the SAVER method.
Default is TRUE.}

\item{scImpute}{a boolean variable that defines whether to impute the raw data using the scImpute method.
Default is TRUE.}

\item{scRMD}{a boolean variable that defines whether to impute the raw data using the scRMD method.
Default is TRUE.}

\item{Seurat}{a boolean variable that defines whether to impute the raw data using the Seurat method.
Default is TRUE.}

\item{ALRA.k}{the rank of the rank-k approximation in ALRA. Set to 0 for automated choice of k.
Default is 0.}

\item{ALRA.q}{the number of power iterations in randomized SVD used by ALRA. Default is 10.}

\item{DCA.normtype}{a string variable specifying the type of size factor estimation in DCA.
Possible values: "deseq", "zheng". Default is "zheng".}

\item{DCA.type}{a string variable specifying type of autoencoder in DCA. Possible values:
"normal", "poisson", "nb", "nb-shared", "nb-conddisp", "nb-fork", "zinb", "zinb-shared", "zinb-conddisp",
"zinb-fork". Default is "zinb-conddisp".}

\item{DCA.l2}{a real number specifying the L2 regularization coefficient in DCA.  Default is 0.}

\item{DCA.l1}{a real number specifying the L1 regularization coefficient in DCA.  Default is 0.}

\item{DCA.l2enc}{a real number specifying the encoder-specific L2 regularization coefficient in DCA.
Default is 0.}

\item{DCA.l1enc}{a real number specifying the encoder-specific L1 regularization coefficient in DCA.
Default is 0.}

\item{DCA.ridge}{a real number specifying the L2 regularization coefficient for dropout probabilities
in DCA. Default is 0.}

\item{DCA.gradclip}{a real number specifying the Clip grad values in DCA. Default is 5.}

\item{DCA.activation}{a string value specifying the activation function of hidden unit in DCA. Default is "relu".}

\item{DCA.hiddensize}{a string vector specifying the size of hidden layers in DCA. Default is "64,32,64".}

\item{DCA.hyper}{a logical value specifying whether hyperparameter search is performed in DCA.}

\item{DCA.hypern}{an integer specifying the number of samples drawn from hyperparameter distributions
during optimization in DCA. Default is 1000.}

\item{DrImpute.ks}{an integer vector specifying the number of cell clustering groups in DrImpute.
Default is 10:15.}

\item{DrImpute.dists}{a string vector specifying the distance metrics in DrImpute. Default is
c("spearman", "pearson").}

\item{DrImpute.method}{a string specifying the method used for imputation in DrImpute. Use "mean"
for mean imputation, "med" for median imputation.}

\item{DrImpute.cls}{a matrix specifying the clustering information manually provided by users in DrImpute.
The rows represent different clusterings, and the columns represent cells. Default is NULL,
which means the user do not provide the clustering information.}

\item{MAGIC.k}{an integer specifying the number of nearest neighbors on which to build kernel in MAGIC.
Default is 10.}

\item{MAGIC.alpha}{an integer specifying the decay rate of kernel tails in MAGIC. Default is 15.}

\item{MAGIC.t}{an integer specifying the diffusion time for the Markov Affinity Matrix in MAGIC.
Default is "auto". For detail about the approach to set paramter t automatically,
please refer to the reference.}

\item{MAGIC.npca}{an integer specifying the number of PCA components in MAGIC.
Default is 20.}

\item{MAGIC.t.max}{an integer specifying the maximum value of t to test for automatic t selection in MAGIC.
Default is 20.}

\item{MAGIC.knn.dist.method}{a string value specifying the metric for building kNN graph in MAGIC.
Recommended values: "euclidean", "cosine". Default is "euclidean".}

\item{MAGIC.n.jobs}{an integer specifying the number of jobs used for computation in MAGIC. If -1 all CPUs are used.
If 1 is given, no parallel computing code is used at all. For n.jobs below -1, (n.cpus + 1 + n.jobs)
are used. Thus for n.jobs = -2, all CPUs but one are used.}

\item{SAVER.do.fast}{a boolean variable specifying whether the prediction step is
approximated in SAVER. Default is TRUE.}

\item{SAVER.ncores}{number of cores to use in SAVER. Default is 1.}

\item{SAVER.size.factor}{a vector of cell size specifying the normalization factors in SAVER.
If the data is already normalized or normalization is not desired, set size.factor = 1.
Default uses mean library size normalization.}

\item{SAVER.npred}{number of genes for regression prediction in SAVER. Selects the top npred genes in
terms of mean expression for regression prediction. Default is all genes.}

\item{SAVER.null.model}{a boolean variable specifying whether to use mean gene expression as prediction
in SAVER. Default is FALSE}

\item{SAVER.mu}{matrix of prior means in SAVER.}

\item{scImpute.drop_thre}{a number (between 0 and 1) specifying the threshold on dropout probability in scImpute.
Default is 0.5.}

\item{scImpute.Kcluster}{an integer specifying the number of cell subpopulations in scImpute. Default is 10.}

\item{scImpute.labeled}{a boolean variable indicating whether cell type information is given in scImpute. Default is FALSE.}

\item{scImpute.labels}{a character vector specifying the cell type in scImpute. Only needed when \code{labeled = TRUE}.
Default is NULL}

\item{scImpute.genelen}{an integer vector giving the length of each gene in scImpute.  Default is NULL.}

\item{scImpute.ncores}{an integer specifying the number of cores used for parallel computation in scImpute. Default is 1.}

\item{scRMD.tau}{a non-negative real number specifying the tuning parameter to penalize the sparse term. Default is NULL.}

\item{scRMD.lambda}{a non-negative real number specifying the tuning parameter to penalize the row rank term. Default is NULL.}

\item{scRMD.candidate}{a real number (0 to 1) specifying the cutoff for candidate drop out. Default is 0.05.}

\item{Seurat.genes.use}{a vector of genes that can be used for building the models in Seurat. Default use the high
variable gene detected by the \code{FindVariableGenes} in the Seurat package.}

\item{Seurat.genes.fit}{a vector of genes to impute values for. Default is all genes}

\item{Seurat.gram}{a logical value specifying whether the Gram matrix is precomputed in Seurat. Default is TRUE.}

\item{Seurat.genes.use}{a vector of genes that can be used for building the models in Seurat. Default use the high
variable gene detected by the \code{FindVariableGenes} in the Seurat package.}

\item{Seurat.genes.fit}{a vector of genes to impute values for. Default is all genes.}
}
\value{
a list with the following components
\item{\code{count.EnImpute.log}}{Imputed count matrix generated by EnImpute (log scale).}
\item{\code{count.EnImpute.exp}}{Imputed count matrix generated by EnImpute (exp scale).}
\item{\code{count.imputed.individual.exp}}{Imputed count matrices generated by different individual imputation methods (exp scale).}
\item{\code{Methods.used}}{The individual methods used by EnImpute.}
}
\description{
This function is implemented to perform EnImpute on a raw read count matrix. EnImpute is an ensemble
learning-based method for imputing dropout values in scRNA-seq data. The current implementation of
EnImpute integrates seven state-of-the-art methods: Adaptively-thresholded low rank approximation (ALRA),
Deep count autoencoder network (DCA), DrImpute, Markov affinity-based graph imputation of cells (MAGIC)
Single-cell analysis via expression recovery (SAVER), scImpute, scRMD and Seurat. EnImpute first run the
seven individual imputation methods, and then use the trimmed mean of the imputed values generated
by different individual methods as a consensus result. This function depends on the follwing R package:
DrImpute, Rmagic, SAVER, scImpute, scRMD, Seurat, rsvd. These packages will be automatically installed along
with EnImpute. EnImpute also depends on the following two Python packages: dca and MAGIC. Before
installing the R package EnImpute, please install the two Python packages following the corresponding
readme files, and check whether they can be run from the command line.
}
\examples{
data("baron")
baron_imputation_result = EnImpute(baron$count.samp)

# data("manno")
# manno_imputation_result = EnImpute(manno$count.samp)

# data("zeisel")
# zeisel_imputation_result = EnImpute(zeisel$count.samp)
}
\references{
[1] Linderman, G. C. et al. (2018). Zero-preserving imputation of scrna-seq data using low-rank approximation. bioRxiv.\cr
[2] Eraslan, G. et al. (2019). Single-cell rna-seq denoising using a deep count autoencoder. Nat Commun, 10(1), 390.\cr
[3] Kwak, I.-Y. et al. (2018). Drimpute: Imputing dropout events in single cell rna sequencing data. BMC Bioinformatics, 19, 220.\cr
[4] van Dijk, D. et al. (2018). Recovering gene interactions from single-cell data using data diffusion. Cell, 174, 1–14.\cr
[5] Huang, M. et al. (2018). Saver: gene expression recovery for single-cell rna sequencing. Nat Methods, 15, 539–542.\cr
[6] Li, W. V. and Li, J. J. (2018). An accurate and robust imputation method scimpute for single-cell rna-seq data. Nat Commun, 9(1), 997.\cr
[7] Chen, C. et al. (2018). scrmd: Imputation for single cell rna-seq data via robust matrix decomposition. bioRxiv, page 459404.\cr
[8] Satija, R. et al. (2015). Spatial reconstruction of single-cell gene expression data. Nat. Biotechnol., 33(5), 495–502.\cr
[9] Zhang, X. F. et al. EnImpute: imputing dropout events in single cell RNA sequencing data via ensemble learning, 2019.\cr
}
\author{
Xiao-Fei Zhang  <zhangxf@mail.ccnu.edu.cn>
}
